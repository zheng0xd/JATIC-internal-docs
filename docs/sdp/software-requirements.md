
# Software Requirements

The following specifies standards and requirements for a Python project's: structure, code design and standards, code style, documentation style, test suite, and maintenance regimen.

The [rai-toolbox](https://github.com/mit-ll-responsible-ai/responsible-ai-toolbox) is an example of a project that adheres to these standards. Developers are encouraged to use this project as a reference in order to see the SDP's software requirements put into practice.

## Project Structure

The following is a description of the basic structure for a Python project that adheres to the [Python Packaging Authority](https://www.pypa.io/en/latest/)'s standards. This structure helps to ensure compatibility with 3rd party utilities and project analysis tools. [This tutorial](https://packaging.python.org/en/latest/tutorials/packaging-projects/) demonstrates the process for creating a project that adheres to this structure.

- Although not part of pypa's standard, we also suggest that modules and packages that are not part of a project's public API should have a leading underscore in its name, or it should reside in a directory whose name possesses the leading underscore.
- The project's Python source code should be isolated in a top-level directory named `src/`. This ensures that the Python package cannot be imported by the test suite unless the package has been installed locally.
- [Project metadata](https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#declaring-project-metadata) should be specified in the `pyproject.toml` file or `setup.cfg` file when possible.
- A version string should be be accessible at runtime via the `__version__` attribute of the project's top-level Python module. See the section Versioning, Compatibility, and Maintenance Expectations for more details.
- Tools that have project-level configurations, such as `tox`, `coverage.py` and `isort`, should be configured using `pyproject.toml` when possible. Note that `flake8` and `pre-commit` do not support `pyproject.toml`. [`flake518`](https://github.com/carstencodes/flake518) is a small wrapper around `flake8` that provides support for `pyproject.toml`.
- The project's test suite should be in a `tests/` directory located at the top-level of the project.
- Public Python interfaces should include type annotations, and the project should include an empty `py.typed` file in its `src/`<lib_name> directory that is [included as part of the project's package-data](https://github.com/mit-ll-responsible-ai/responsible-ai-toolbox/blob/21142af92c3484e2aa670b3e09c1c70ba35c866d/pyproject.toml#L81-L82). This is to comply with [PEP 561's](https://peps.python.org/pep-0561/) specification for Python packages to distribute type information to users.
- A project that provides users with custom types – that are predominantly meant for use as type annotations – should provide them to users through a submodule named `.typing`.

The following is an example layout of such a project:

```
# structure of a Python project named 'jatic_vision'

jatic_vision/
├── LICENSE.txt
├── pyproject.toml
├── README.md
├── src/
│   └── jatic_vision/
│       ├── py.typed
│       ├── __init__.py
│       ├── models.py
│       └── _internals.py
└── tests/
    ├── conftest.py
    └── test_models.py
```

### Dependency Management

A project's required dependencies should be kept to a minimum, in part, by isolating optional dependencies to appropriate sub-modules. For example, suppose that the project `my_lib` leverages `matplotlib` to provide visualization capabilities - it can make `matplotlib` an optional dependency by restricting its usage to the `my_lib.viz` submodule, and by listing `matplotlib` under the `project.optional-dependencies` section of the project's `pyproject.toml` file. In this way, users can leverage `my_lib` without installing `matplotlib` unless they explicitly utilize features from `my_lib.viz`.

A project's installation dependencies, both required and optional, must include minimum version numbers in the `pyproject.toml` file.


#### Poetry

Poetry is required for internal development of software in the JATIC program. At the current moment of writing, poetry is the most complete dependency tool in the python ecosystem and has been used to find dependency problems already. 

Consumers of JATIC tools can use whatever dependency management their team thinks is best, but we strongly recommend Poetry. 

Teams *should* commit the lock file that is generated by poetry. CI and automation tools can install poetry and use it directly. If there is a need to transition slowly, poetry can generate a `requirements.txt` file, but ideally poetry should be used from development to test to production. 

The explanation for this requirement is as follows:

Dependencies have dependencies known as transitive dependencies.  When a project is in use over a long enough time the minimum updates and complexity come from security updates.  In addition to security updates, packages may improve or be unmaintained so the package tree needs to change completely.  Ideally, this process would involve a high-quality dependency resolver which relies on semantic versioning (explained below) as well as tooling to make this process work well over time.  The python ecosystem has many tools that exist to manage dependencies but currently [poetry](https://python-poetry.org) solves this problem space very well.

Dependencies need to work together and be repeatable.  If the project cannot run because something on the internet changed then the build is not repeatable.  Having many optional dependencies in groups causes the burden of permutations to move to the testing phase.  Eventually, all dependencies (whether optional or not) have to be combined together in a dependency tree.  This includes dependencies of dependencies.  It's too hard to solve by hand, poetry has a good resolver currently.

When specifying what dependencies are needed, developers should try to be as loose with requirements as they can but then be strict when presented with a problem.  For example, let's suppose a project needs `numpy`.  In the `pyproject.toml` file the version would specified as loosely as possible `^1.24.2` instead of an exact `1.24.2`.  If a CVE for `numpy` required version 1.25.0 and above then the change would be made to use `^1.25.0` and only made `1.25.0` if other packages had issues resolving the dependency tree.

Using poetry allows for repeatable builds and semantic versioning to be leveraged to make the software operate more smoothly over time.  Using pip or virtual environments does not solve the same sets of problems.


## Project Test Suite

A JATIC Python project is to maintain an automated test suite. The primary distinction between a collection of manual tests versus an automated test suite is that, for the latter, a single command line call can collect, run, and report the results of all (or a subset of) a suite's tests. The project's automated test suite should leverage the following:

- The [pytest framework](https://docs.pytest.org/) for collecting, initializing, and running tests.
  - The standard library's `unittest` module can be relied on for mocks, monkey patches, and doctests, all of which can be leveraged within a pytest-driven test suite. Otherwise, `unittest` should not be used as a test-runner and pytest-style test functions should be preferred over `unittest`-style test classes.
  - The `nosetest` framework is no longer maintained and should not be used.
- [`tox`](https://tox.readthedocs.io/en/latest/) for automating the process of building isolated test environments, installing dependencies, and running tools (e.g. running tests in a Python 3.10 environment against the nightly build of PyTorch). `tox` helps normalize the process of running automated jobs across platforms (e.g. the same tox job-launch commands can be used on local machines as well as on CI/CD servers).
  - `tox` should be used to run a project's test suite across all supported Python versions.
- The [`coverage.py`](https://coverage.readthedocs.io/en/coverage-5.3/) tool (with the [pytest-cov plugin](https://pypi.org/project/pytest-cov/)) to track the parts of the project's codebase that are and are not exercised by the test suite. Projects are free to specify their own code-coverage requirements (e.g. 85% code coverage), or to forego having a specific coverage requirement. That being said, the project's coverage metrics should be reported by a tox job.
- [pyright](https://github.com/microsoft/pyright) is a fast type checker that performs incremental updates when files are modified.

Teams are advised to read through this [introductory tutorial to property based testing](https://github.com/rsokl/testing-tutorial). [Property-based testing](https://increment.com/testing/in-praise-of-property-based-testing/) is an effective approach to testing scientific software for which functions often cannot be tested against "oracles" (i.e. sources of known correct outputs for diverse inputs to functions).

Explicit DevSecOps pipeline requirements that will be enforced via GitLab CI/CD can be found in the [DevSecOps Testing Requirements](./DevSecOps%20Testing%20Requirements.md) document.

## Versioning, Compatibility, and Maintenance Expectations

A Python package's releases should utilize [semantic versioning](https://semver.org/) (i.e. the version number is structured as `MAJOR.MINOR.PATCH`).

- Projects like [setuptools scm](https://github.com/pypa/setuptools_scm/) and [versioneer](https://github.com/python-versioneer/python-versioneer) can be used to extract a project's version string from version control metadata (e.g. a tag name from git). Using such a tool is recommended as it helps to eliminate from a project's release process the manual, error-prone steps of updating an embedded version string.

A package's support for Python versions should be determined by [the version support table](https://devguide.python.org/versions/) provided by the Python developer's guide. JATIC projects should support (and test against) Python versions that are still receiving security updates. A project should add support for a new version of Python once it has been officially released and when the project's dependencies permit it. Dependencies that prevent compatibility with the full range of supported Python versions should be made optional if possible, or otherwise must be approved by JATIC project organizers.

NumPy provides its own community policy standard, [NEP 29](https://numpy.org/neps/nep-0029-deprecation_policy.html), that calls for packages in the "Scientific Python ecosystem" to adopt a common time window-based approach to supporting Python and NumPy versions. This policy drops support for Python versions significantly earlier than the aforementioned timeline from the Python developer's guide. JATIC projects should abide by the more conservative version support schedule, but heed the fact that popular dependencies will adopt the NEP 29 timeline. As such, JATIC packages will need to maintain a sufficiently expansive test-job matrix to ensure that the minimum/maximum documented dependency versions are being tested, and that new project features do not inadvertently break compatibility.

The project's tox jobs should exercise the minimum and maximum documented dependencies, and should include jobs that exclude optional requirements to ensure that they are not required for installation nor for exercising core functionality.

## Code Design, Standards, and Guidelines

[Python code should comply with the JATIC Python Coding Guidelines](./guidelines/Python%20Coding%20Guidelines.md). These should be followed for new code. Existing code can be permitted to ignore guidelines until time is allocated to revise and update the code.

### Code Style and Formatting

Adhering to a clear and consistent style is critical for writing maintainable code, especially when coordinating multi-organization collaborations. That being said, enforcing such standards can be tedious and labor-intensive. Fortunately, several powerful tools exist that can help automate consistent code styling. Compliance with the [Python Coding Guidelines](./guidelines/Python%20Coding%20Guidelines.md) should help create consistent style. Additional style and formatting consistency should come by application of formatting tools.

JATIC Python projects should leverage the following automated tools for formatting code and for enforcing style:

- [black](https://black.readthedocs.io/en/stable/): is a PEP 8 compliant opinionated code formatter. It is designed to be run on a project's source code and tests in order to modify these text files in-place so that the resulting files have canonicalized formatting. black is limited in the ways that it can be configured; this is by-design so that teams do not spend time squabbling over things like white-space conventions. Note that [black can be run on Jupyter notebooks](https://black.readthedocs.io/en/stable/getting_started.html#installation) as well.
- [isort](https://pycqa.github.io/isort/): sorts imports in alphabetical order and into sections (e.g. std-lib imports, third-party imports, and first-party imports). Vendors should [configure isort to be compatible with black](https://pycqa.github.io/isort/docs/configuration/black_compatibility.html) according to these instructions.
- [flake8](https://github.com/PyCQA/flake8): analyzes your code to enforce the PEP8 standards and to catch bad code patterns, such as unused imports and variables. This is not an auto-formatter, rather when it is run from the command line it will generate a report of code style violations in a code base, which includes their locations and error codes. Vendors can [configure flake8](https://flake8.pycqa.org/en/latest/user/configuration.html) to skip particular files (e.g. one may want to avoid scanning a `.py` file that was auto-generated by the Sphinx documentation framework).

At its most basic level, our code style standards for Python-based projects are derived from the [PEP 8 Style Guide](https://peps.python.org/pep-0008/), with additional formatting specifications that are best summarized as "let auto-formatters do their thing". It is recommended that these three tools be applied in an automated fashion. [Pre-commit hooks](https://pre-commit.com/) make it simple to run these tools on a per-commit basis, and CI/CD processes should be designed to apply/enforce these tools before a branch can be merged into protected branches (e.g., `dev`, `main`). [Here is an example of a pre-commit configuration file](https://github.com/mit-ll-responsible-ai/responsible-ai-toolbox/blob/main/.pre-commit-config.yaml) (and an accompanying [isort config](https://github.com/mit-ll-responsible-ai/responsible-ai-toolbox/blob/21142af92c3484e2aa670b3e09c1c70ba35c866d/pyproject.toml#L86-L89)) that runs these three tools.

## Documentation

JATIC projects should utilize consistent conventions and styles in their documentation strings, documentation websites, and in the organization of tutorials, how-to guides, and other instructional materials. Guidance on documentation within code can be found in [Python Coding Guidelines](./guidelines/Python%20Coding%20Guidelines.md)

### Project Documentation
Project documentation should leverage [the Sphinx project](https://www.sphinx-doc.org/en/master/) to generate hierarchical documentation in HTML (or LaTeX for a printable version). Using the [reStructuredText](https://docutils.sourceforge.io/rst.html) markup language for the source content recommended over markdown. The [PyData Sphinx Theme](https://pydata-sphinx-theme.readthedocs.io/en/stable/) is recommended for providing, e.g., the css styling, fonts for the HTML pages; it is popular, actively supported, and includes rich features like code-tabs and a dark-theme.

Documentation should follow the guidance in [Python Coding Guidelines](./guidelines/Python%20Coding%20Guidelines.md).

### Documentation Organization

It is recommended that projects leverage the [Diátaxis framework](https://diataxis.fr/) for technical documentation authoring. This prescribes four "modes" of documentation – tutorials, how-to guides, explanations, and technical reference – for introducing users to a project. This can help to create a consistent learning experience for users who are leveraging multiple JATIC projects, and it helps to save JATIC vendors from "reinventing the wheel" when it comes to writing project documentation. A "change log" should also be maintained, detailing the release notes of the project's respective versions, as part of the documentation site.
